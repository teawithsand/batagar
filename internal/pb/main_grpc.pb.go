// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package pb

import (
	context "context"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// ManifestClient is the client API for Manifest service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ManifestClient interface {
	GetManifest(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*CoordinatorManifest, error)
}

type manifestClient struct {
	cc grpc.ClientConnInterface
}

func NewManifestClient(cc grpc.ClientConnInterface) ManifestClient {
	return &manifestClient{cc}
}

var manifestGetManifestStreamDesc = &grpc.StreamDesc{
	StreamName: "GetManifest",
}

func (c *manifestClient) GetManifest(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*CoordinatorManifest, error) {
	out := new(CoordinatorManifest)
	err := c.cc.Invoke(ctx, "/batagar.Manifest/GetManifest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ManifestService is the service API for Manifest service.
// Fields should be assigned to their respective handler implementations only before
// RegisterManifestService is called.  Any unassigned fields will result in the
// handler for that method returning an Unimplemented error.
type ManifestService struct {
	GetManifest func(context.Context, *empty.Empty) (*CoordinatorManifest, error)
}

func (s *ManifestService) getManifest(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.GetManifest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/batagar.Manifest/GetManifest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.GetManifest(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// RegisterManifestService registers a service implementation with a gRPC server.
func RegisterManifestService(s grpc.ServiceRegistrar, srv *ManifestService) {
	srvCopy := *srv
	if srvCopy.GetManifest == nil {
		srvCopy.GetManifest = func(context.Context, *empty.Empty) (*CoordinatorManifest, error) {
			return nil, status.Errorf(codes.Unimplemented, "method GetManifest not implemented")
		}
	}
	sd := grpc.ServiceDesc{
		ServiceName: "batagar.Manifest",
		Methods: []grpc.MethodDesc{
			{
				MethodName: "GetManifest",
				Handler:    srvCopy.getManifest,
			},
		},
		Streams:  []grpc.StreamDesc{},
		Metadata: "main.proto",
	}

	s.RegisterService(&sd, nil)
}

// CoordinatorClient is the client API for Coordinator service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CoordinatorClient interface {
	ListCorpusFiles(ctx context.Context, in *ListCorpusFilesRequest, opts ...grpc.CallOption) (Coordinator_ListCorpusFilesClient, error)
	GetCorpusFile(ctx context.Context, in *GetCorpusFileRequest, opts ...grpc.CallOption) (*CorpusFile, error)
	NewCrasherFound(ctx context.Context, in *NewCrasherFoundRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	NewCorpusFound(ctx context.Context, in *NewCorpusFoundRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	NewStats(ctx context.Context, in *NewStatsRequest, opts ...grpc.CallOption) (*empty.Empty, error)
}

type coordinatorClient struct {
	cc grpc.ClientConnInterface
}

func NewCoordinatorClient(cc grpc.ClientConnInterface) CoordinatorClient {
	return &coordinatorClient{cc}
}

var coordinatorListCorpusFilesStreamDesc = &grpc.StreamDesc{
	StreamName:    "ListCorpusFiles",
	ServerStreams: true,
}

func (c *coordinatorClient) ListCorpusFiles(ctx context.Context, in *ListCorpusFilesRequest, opts ...grpc.CallOption) (Coordinator_ListCorpusFilesClient, error) {
	stream, err := c.cc.NewStream(ctx, coordinatorListCorpusFilesStreamDesc, "/batagar.Coordinator/ListCorpusFiles", opts...)
	if err != nil {
		return nil, err
	}
	x := &coordinatorListCorpusFilesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Coordinator_ListCorpusFilesClient interface {
	Recv() (*CorpusFileHeader, error)
	grpc.ClientStream
}

type coordinatorListCorpusFilesClient struct {
	grpc.ClientStream
}

func (x *coordinatorListCorpusFilesClient) Recv() (*CorpusFileHeader, error) {
	m := new(CorpusFileHeader)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var coordinatorGetCorpusFileStreamDesc = &grpc.StreamDesc{
	StreamName: "GetCorpusFile",
}

func (c *coordinatorClient) GetCorpusFile(ctx context.Context, in *GetCorpusFileRequest, opts ...grpc.CallOption) (*CorpusFile, error) {
	out := new(CorpusFile)
	err := c.cc.Invoke(ctx, "/batagar.Coordinator/GetCorpusFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var coordinatorNewCrasherFoundStreamDesc = &grpc.StreamDesc{
	StreamName: "NewCrasherFound",
}

func (c *coordinatorClient) NewCrasherFound(ctx context.Context, in *NewCrasherFoundRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/batagar.Coordinator/NewCrasherFound", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var coordinatorNewCorpusFoundStreamDesc = &grpc.StreamDesc{
	StreamName: "NewCorpusFound",
}

func (c *coordinatorClient) NewCorpusFound(ctx context.Context, in *NewCorpusFoundRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/batagar.Coordinator/NewCorpusFound", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var coordinatorNewStatsStreamDesc = &grpc.StreamDesc{
	StreamName: "NewStats",
}

func (c *coordinatorClient) NewStats(ctx context.Context, in *NewStatsRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/batagar.Coordinator/NewStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CoordinatorService is the service API for Coordinator service.
// Fields should be assigned to their respective handler implementations only before
// RegisterCoordinatorService is called.  Any unassigned fields will result in the
// handler for that method returning an Unimplemented error.
type CoordinatorService struct {
	ListCorpusFiles func(*ListCorpusFilesRequest, Coordinator_ListCorpusFilesServer) error
	GetCorpusFile   func(context.Context, *GetCorpusFileRequest) (*CorpusFile, error)
	NewCrasherFound func(context.Context, *NewCrasherFoundRequest) (*empty.Empty, error)
	NewCorpusFound  func(context.Context, *NewCorpusFoundRequest) (*empty.Empty, error)
	NewStats        func(context.Context, *NewStatsRequest) (*empty.Empty, error)
}

func (s *CoordinatorService) listCorpusFiles(_ interface{}, stream grpc.ServerStream) error {
	m := new(ListCorpusFilesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return s.ListCorpusFiles(m, &coordinatorListCorpusFilesServer{stream})
}
func (s *CoordinatorService) getCorpusFile(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCorpusFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.GetCorpusFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/batagar.Coordinator/GetCorpusFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.GetCorpusFile(ctx, req.(*GetCorpusFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *CoordinatorService) newCrasherFound(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewCrasherFoundRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.NewCrasherFound(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/batagar.Coordinator/NewCrasherFound",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.NewCrasherFound(ctx, req.(*NewCrasherFoundRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *CoordinatorService) newCorpusFound(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewCorpusFoundRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.NewCorpusFound(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/batagar.Coordinator/NewCorpusFound",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.NewCorpusFound(ctx, req.(*NewCorpusFoundRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *CoordinatorService) newStats(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.NewStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/batagar.Coordinator/NewStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.NewStats(ctx, req.(*NewStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

type Coordinator_ListCorpusFilesServer interface {
	Send(*CorpusFileHeader) error
	grpc.ServerStream
}

type coordinatorListCorpusFilesServer struct {
	grpc.ServerStream
}

func (x *coordinatorListCorpusFilesServer) Send(m *CorpusFileHeader) error {
	return x.ServerStream.SendMsg(m)
}

// RegisterCoordinatorService registers a service implementation with a gRPC server.
func RegisterCoordinatorService(s grpc.ServiceRegistrar, srv *CoordinatorService) {
	srvCopy := *srv
	if srvCopy.ListCorpusFiles == nil {
		srvCopy.ListCorpusFiles = func(*ListCorpusFilesRequest, Coordinator_ListCorpusFilesServer) error {
			return status.Errorf(codes.Unimplemented, "method ListCorpusFiles not implemented")
		}
	}
	if srvCopy.GetCorpusFile == nil {
		srvCopy.GetCorpusFile = func(context.Context, *GetCorpusFileRequest) (*CorpusFile, error) {
			return nil, status.Errorf(codes.Unimplemented, "method GetCorpusFile not implemented")
		}
	}
	if srvCopy.NewCrasherFound == nil {
		srvCopy.NewCrasherFound = func(context.Context, *NewCrasherFoundRequest) (*empty.Empty, error) {
			return nil, status.Errorf(codes.Unimplemented, "method NewCrasherFound not implemented")
		}
	}
	if srvCopy.NewCorpusFound == nil {
		srvCopy.NewCorpusFound = func(context.Context, *NewCorpusFoundRequest) (*empty.Empty, error) {
			return nil, status.Errorf(codes.Unimplemented, "method NewCorpusFound not implemented")
		}
	}
	if srvCopy.NewStats == nil {
		srvCopy.NewStats = func(context.Context, *NewStatsRequest) (*empty.Empty, error) {
			return nil, status.Errorf(codes.Unimplemented, "method NewStats not implemented")
		}
	}
	sd := grpc.ServiceDesc{
		ServiceName: "batagar.Coordinator",
		Methods: []grpc.MethodDesc{
			{
				MethodName: "GetCorpusFile",
				Handler:    srvCopy.getCorpusFile,
			},
			{
				MethodName: "NewCrasherFound",
				Handler:    srvCopy.newCrasherFound,
			},
			{
				MethodName: "NewCorpusFound",
				Handler:    srvCopy.newCorpusFound,
			},
			{
				MethodName: "NewStats",
				Handler:    srvCopy.newStats,
			},
		},
		Streams: []grpc.StreamDesc{
			{
				StreamName:    "ListCorpusFiles",
				Handler:       srvCopy.listCorpusFiles,
				ServerStreams: true,
			},
		},
		Metadata: "main.proto",
	}

	s.RegisterService(&sd, nil)
}
